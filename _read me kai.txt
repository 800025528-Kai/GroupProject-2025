So for the classes it would be like this (indentation means top class calls/contains indented ones):
Battle - topmost layer
    Character
        Abilities
            Atk
            buff
            etc

Look at the chatGPT thing:

Taking a closer look at how Atk currently invokes DamageCalculation, then outlining a cleaner layering plus the steps to shift over.

current pain points
Atk mixes data (hit split, tags) with behavior by instantiating DamageCalculation, which makes the class hard to reuse in different contexts (AoE vs single target, buffs applied elsewhere, testing, etc.).
Because DamageCalculation needs both attacker and defender, creating it inside Atk forces Atk to know about battle state, which should really live higher up (an action resolver or combat engine).
Returning arrays with already-applied damage means you can’t easily reuse the same Atk definition for multiple targets or simulations.
recommended layering
Ability data layer (Atk, Buff, Passive, Abilities)
These classes remain pure data/configuration. Atk exposes hit metadata (hitSplit, altHitSplit, flags). No combat logic lives here.

Action layer (CharacterAction, maybe AbilityUse)
Represents “Character X uses Ability Y on Target(s)”. It pulls the right Atk or Buff from Abilities, but still doesn’t calculate numbers.

Resolution layer (DamageResolver / CombatEngine)
A dedicated service that takes an AttackContext (attacker, defenders, selected Atk, hit index, etc.) and internally owns DamageCalculation. It loops through targets, applies per-hit damage, handles AoE/Blast falloff, and triggers follow-up effects.

Math layer (DamageCalculation)
Remains a stat-focused utility. It receives a fully populated context (attacker, defender, ability multiplier) from the resolver and returns a single hit’s base damage. It no longer needs to know about hit splits—just the effective multiplier for that hit.

This separation keeps Atk reusable and lets you inject different resolvers (single-target, AoE, counterattack, simulation) without touching the ability definitions.

migration checklist
Refactor Atk so it only stores metadata and exposes accessors like List<Double> getHitSplit() and boolean isAoE(). Remove the hitSplitDmg/altHitSplitDmg methods entirely.
Introduce an AttackContext record/class containing attacker, defender(s), ability multiplier, hit index, etc. This keeps method signatures tidy when the resolver calls DamageCalculation.
Add a DamageResolver (or expand ActionManager) with methods such as resolveAttack(Character attacker, List<Character> targets, Atk atk). Inside:
Iterate over atk.getHitSplit().
For each target, instantiate DamageCalculation(attacker, target, hitMultiplier) and sum/record the results.
Handle AoE logic (e.g., distribute hit splits, adjust for isBlast).
Update callers (CharacterAction, future battle loop) to request the resolver instead of mutating Atk.
Keep DamageCalculation pure: one public calculateDamage() per hit, no knowledge of arrays or repeating hits.
Once these pieces exist, the Main tester (or future battle loop) will look like:

Pick a CharacterAction.
Ask the resolver to process it, passing the attacker, chosen targets, and the relevant Atk object.
Use the returned per-target damage for HP deductions, logging, etc.
This approach lets you add features—like damage previews, simulations, or alternate scaling—without ever editing Atk. It also makes unit tests simpler: you can test DamageCalculation in isolation, then test DamageResolver with mocked attackers/targets, and keep ability definitions as static fixtures.

Let me know if you’d like help drafting the new resolver or reorganizing the packages; happy to mock up the new classes.


battle
    - Ability
        - combat engine
            - handles interaction
                - apply dmg
                    - by DamageCalculation